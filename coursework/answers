1: Elixir and Erlang use the BEAM Virtual Machine which is a single Operating System process. BEAM assigns one scheduler per operating system thread by default; which then schedules Erlang processes to that thread. The number of processes created is not constrained to operating system limits.

A process is an instance of a function being executed. Should the need arise, this code can be scaled out by spawning more proceses to run the same code The processes will never share state but instead use asychronous message passing if they need to share data during computations.

A node is a running BEAM Virtual Machine inside which processes can be run. Nodes are run on a physical machine with the possibility of running multiple nodes on a single machine. Like processes, nodes can also communicate with each other through message passing however before message passing can be done between nodes, a node has establish a connection with other nodes by invoking Node.connect() in the code and passing the node and machine name. Once connected, processes between nodes can be invoked by using the Node.spawn() function or looking for the process ID in the global registry if a unique process ID was registered there.

4: In an asynchronous message passing system, there are no upper bounds on time taken to deliver a message as a message can take an infinite number of cycles to deliver. Message delivery failure can be due to message delay or a process crashing. With regards to broadcast implementation B, as message delivery can take an infinite amount of steps, the message may come long after other messages have been received meaning the messages on all processes will not be received in the same order. There is also no guarantee that processes will get m1, m2 because of no check on message delivery. Asynchronous execution of message delivery models a reliable system in which it is assumed no message is lost and no process stops working.
